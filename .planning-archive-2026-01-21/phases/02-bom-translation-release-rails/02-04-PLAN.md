---
phase: 02-bom-translation-release-rails
plan: 04
type: execute
wave: 1
depends_on:
  - 02-01
  - 02-02
  - 02-03
files_modified:
  - src-tauri/src/commands.rs
  - src/lib/bom/zw1-exporter.ts
  - src/types/bom.ts
  - src/stores/bom-export-store.ts
  - src/components/bom-translation/ExportProgressDialog.tsx
  - src/components/bom-translation/RunHistoryDialog.tsx
  - src/pages/bom-translation-page.tsx
  - src/lib/db/client.ts
autonomous: true

must_haves:
  truths:
    - "User can export validated BOM data to .zw1 format deterministically"
    - "Export progress is shown with real-time status updates"
    - "Completed runs are recorded in history with input file, mapping snapshot, and output metadata"
    - "User can view run history and re-run past jobs using stored input files and settings"
    - "Export is blocked if validation errors exist"
  artifacts:
    - path: "src/lib/bom/zw1-exporter.ts"
      provides: "Zw1Exporter class for deterministic .zw1 generation"
      contains: "exportToZw1, generateZw1Content"
    - path: "src-tauri/src/commands.rs"
      provides: "Tauri command for file write with hash computation"
      contains: "write_zw1_file"
    - path: "src/stores/bom-export-store.ts"
      provides: "Zustand store for export orchestration and run history"
      contains: "useBOMExportStore"
  key_links:
    - from: "src/stores/bom-export-store.ts"
      to: "src-tauri/src/commands.rs"
      via: "invoke('write_zw1_file')"
      pattern: "invoke\\('write_zw1_file'"
    - from: "src/stores/bom-export-store.ts"
      to: "src/lib/db/client.ts"
      via: "bomRuns.create, bomRuns.updateStatus"
      pattern: "bomRuns\\.(create|updateStatus|getByPackage|getById)"
    - from: "src/stores/bom-export-store.ts"
      to: "src/lib/bom/zw1-exporter.ts"
      via: "Zw1Exporter.exportToZw1"
      pattern: "Zw1Exporter\\.exportToZw1"
---

<objective>
Implement deterministic .zw1 export with progress tracking, run history recording, and history/replay UI.

Purpose: Complete the BOM Translation workflow with reliable export and full audit trail.
Output: Working export to .zw1, recorded run history, and history browser with re-run capability.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/02-bom-translation-release-rails/02-CONTEXT.md
@.planning/phases/02-bom-translation-release-rails/02-01-PLAN.md
@.planning/phases/02-bom-translation-release-rails/02-02-PLAN.md
@.planning/phases/02-bom-translation-release-rails/02-03-PLAN.md

@src/types/bom.ts
@src/lib/db/client.ts
@src-tauri/src/commands.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Zw1Exporter for deterministic .zw1 generation</name>
  <files>src/lib/bom/zw1-exporter.ts</files>
  <action>
Create `src/lib/bom/zw1-exporter.ts` with:

**Export class:**
```typescript
import { BomRow } from '@/types/bom';

export interface Zw1ExportOptions {
  format: 'zw1';
  version: string;
  includeMetadata: boolean;
}

export interface Zw1ExportResult {
  content: string;
  checksum: string; // SHA-256 hash of content
  lineCount: number;
}

export class Zw1Exporter {
  /**
   * Export BOM rows to .zw1 format
   * Format assumption: Fixed-width or delimited format (adjust based on actual .zw1 spec)
   */
  static async exportToZw1(
    rows: BomRow[],
    options: Zw1ExportOptions
  ): Promise<Zw1ExportResult> {
    // Sort by part_number, then row_number for determinism
    const sortedRows = [...rows].sort((a, b) => {
      const pnCompare = (a.part_number || '').localeCompare(b.part_number || '');
      if (pnCompare !== 0) return pnCompare;
      return a.rowNumber - b.rowNumber;
    });

    // Generate .zw1 content
    const lines: string[] = [];

    // Header (if format includes it)
    if (options.includeMetadata) {
      lines.push(`# ZW1 BOM Export`);
      lines.push(`# Version: ${options.version}`);
      lines.push(`# Generated: ${new Date().toISOString()}`);
      lines.push(`# Line Items: ${sortedRows.length}`);
      lines.push(''); // Blank line separator
    }

    // Data rows (adjust delimiter/width based on actual spec)
    sortedRows.forEach((row, idx) => {
      const line = [
        (idx + 1).toString().padStart(6), // Line item
        (row.part_number || '').padEnd(30),
        (row.quantity || 0).toString().padStart(6),
        (row.description || '').padEnd(80),
        (row.manufacturer || '').padEnd(40),
        (row.manufacturer_part_number || '').padEnd(30),
      ].join(''); // Fixed-width format

      lines.push(line);
    });

    const content = lines.join('\n');

    // Compute checksum
    const checksum = await this.computeSHA256(content);

    return {
      content,
      checksum,
      lineCount: sortedRows.length,
    };
  }

  /**
   * Compute SHA-256 hash of content
   */
  private static async computeSHA256(content: string): Promise<string> {
    // Use Web Crypto API in Tauri context
    const encoder = new TextEncoder();
    const data = encoder.encode(content);
    const hashBuffer = await crypto.subtle.digest('SHA-256', data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
  }

  /**
   * Generate deterministic export ID for deduplication
   */
  static generateExportId(rows: BomRow[], options: Zw1ExportOptions): string {
    // Create a normalized representation for hashing
    const normalized = rows
      .map(r => ({
        pn: r.part_number || '',
        qty: r.quantity || 0,
        desc: r.description || '',
      }))
      .sort((a, b) => a.pn.localeCompare(b.pn));

    return JSON.stringify({ rows: normalized, options });
  }
}
```

**Note:** Adjust the .zw1 format based on actual specification. This assumes a fixed-width text format.

Error handling:
- Validate rows array is not empty
- Handle missing required fields (log warning, include placeholder)
- Throw if content generation fails
  </action>
  <verify>
Run: `npm run build` and `npm run lint`
  </verify>
  <done>
Zw1Exporter compiles and generates deterministic .zw1 content with checksums.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Tauri command for atomic file write with hash</name>
  <files>src-tauri/src/commands.rs</files>
  <action>
Add a new Tauri command `write_zw1_file` that:

1. Accepts: file path (string), content (string), expected hash (string)
2. Writes content atomically (write to temp, then rename)
3. Computes SHA-256 of written content
4. Verifies hash matches expected
5. Returns: success boolean, actual hash, file size

```rust
#[tauri::command]
async fn write_zw1_file(
    file_path: String,
    content: String,
    expected_hash: String,
) -> Result<WriteResult, String> {
    use sha2::{Sha256, Digest};
    use std::io::Write;
    use std::fs;

    // Compute hash of content
    let mut hasher = Sha256::new();
    hasher.update(content.as_bytes());
    let actual_hash = format!("{:x}", hasher.finalize());

    // Verify hash
    if actual_hash != expected_hash {
        return Err(format!(
            "Hash mismatch: expected {}, got {}",
            expected_hash, actual_hash
        ));
    }

    // Atomic write: temp file then rename
    let temp_path = format!("{}.tmp", file_path);

    // Write to temp
    fs::write(&temp_path, content)
        .map_err(|e| format!("Failed to write temp file: {}", e))?;

    // Atomic rename
    fs::rename(&temp_path, &file_path)
        .map_err(|e| format!("Failed to rename file: {}", e))?;

    // Get file size
    let metadata = fs::metadata(&file_path)
        .map_err(|e| format!("Failed to get metadata: {}", e))?;
    let file_size = metadata.len();

    Ok(WriteResult {
        success: true,
        hash: actual_hash,
        file_size,
    })
}

#[derive(Serialize)]
struct WriteResult {
    success: bool,
    hash: String,
    file_size: u64,
}
```

Register in `tauri::generate_handler!`.

Error handling:
- Return actionable errors for permission issues, disk full, invalid path
- Ensure temp file is cleaned up on failure
  </action>
  <verify>
Run: `cargo check --manifest-path src-tauri/Cargo.toml`
  </verify>
  <done>
Tauri command compiles and can atomically write files with hash verification.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create BOM Export store for orchestration and history</name>
  <files>src/stores/bom-export-store.ts</files>
  <action>
Create `useBOMExportStore` with:

**State:**
- `exporting: boolean`
- `exportProgress: number` (0-100)
- `exportStatus: string` (status message)
- `currentRunId: number | null`
- `runHistory: BomRun[]`
- `selectedRunId: number | null`
- `error: string | null`

**Actions:**
- `startExport(rows: BomRow[], mapping: ColumnMapping, outputPath: string)` - Orchestrates export
- `cancelExport()` - Cancel in-progress export
- `loadRunHistory(packageScopeId: number)` - Load history for current package
- `reRun(runId: number)` - Re-run a past job
- `deleteRun(runId: number)` - Delete run from history
- `clearError()` - Clear error state

**Export workflow:**
1. Validate validation.hasErrors === false (read from bom-data-store)
2. Generate .zw1 content using Zw1Exporter
3. Create bom_run record via DB
4. Store input file via DB
5. Invoke Tauri command to write file
6. Update run record with completion status and output hash
7. Refresh run history

```typescript
import { create } from 'zustand';
import { invoke } from '@tauri-apps/api/core';
import { BomRun, BomRow, ColumnMapping, ExportSettings } from '@/types/bom';
import { Zw1Exporter } from '@/lib/bom/zw1-exporter';
import { bomRuns, bomRunInputs } from '@/lib/db/client';
import { useBomDataStore } from './bom-data-store';
import { toast } from 'sonner';

interface BOMExportState {
  exporting: boolean;
  exportProgress: number;
  exportStatus: string;
  currentRunId: number | null;
  runHistory: BomRun[];
  selectedRunId: number | null;
  error: string | null;

  startExport: (rows: BomRow[], mapping: ColumnMapping, outputPath: string) => Promise<void>;
  cancelExport: () => void;
  loadRunHistory: (packageScopeId: number) => Promise<void>;
  reRun: (runId: number) => Promise<void>;
  deleteRun: (runId: number) => Promise<void>;
  clearError: () => void;
}

export const useBOMExportStore = create<BOMExportState>((set, get) => ({
  exporting: false,
  exportProgress: 0,
  exportStatus: '',
  currentRunId: null,
  runHistory: [],
  selectedRunId: null,
  error: null,

  startExport: async (rows, mapping, outputPath) => {
    const dataStore = useBomDataStore.getState();

    // Check validation
    if (!dataStore.validation.canExport) {
      toast.error('Cannot export: Please fix validation errors first');
      return;
    }

    set({ exporting: true, exportProgress: 0, exportStatus: 'Initializing...', error: null });

    try {
      // Step 1: Generate .zw1 content (25%)
      set({ exportProgress: 25, exportStatus: 'Generating .zw1 file...' });
      const exportResult = await Zw1Exporter.exportToZw1(rows, {
        format: 'zw1',
        version: '1.0',
        includeMetadata: true,
      });

      // Step 2: Create run record (50%)
      set({ exportProgress: 50, exportStatus: 'Recording run...' });
      const packageScopeId = 1; // TODO: Get from active scope store
      const settings: ExportSettings = {
        format: 'zw1',
        version: '1.0',
      };

      const run = await bomRuns.create(
        packageScopeId,
        exportResult.checksum, // input hash = content hash for now
        settings
      );

      set({ currentRunId: run.id });

      // Step 3: Store input file blob (75%)
      set({ exportProgress: 75, exportStatus: 'Storing input file...' });
      const inputFileBlob = new Uint8Array([]); // TODO: Get from translation store
      await bomRunInputs.create(run.id, 'bom.xlsx', inputFileBlob);

      // Step 4: Write output file via Tauri (90%)
      set({ exportProgress: 90, exportStatus: 'Writing output file...' });
      await invoke('write_zw1_file', {
        filePath: outputPath,
        content: exportResult.content,
        expectedHash: exportResult.checksum,
      });

      // Step 5: Update run as completed (100%)
      set({ exportProgress: 100, exportStatus: 'Completing...' });
      await bomRuns.updateStatus(run.id, 'completed', new Date().toISOString());

      toast.success(`Exported ${exportResult.lineCount} line items to .zw1`);

      // Refresh history
      await get().loadRunHistory(packageScopeId);

      set({ exporting: false, exportProgress: 0, exportStatus: '', currentRunId: null });
    } catch (e) {
      const errorMsg = String(e);
      set({ exporting: false, error: errorMsg });

      // Update run as failed
      if (get().currentRunId) {
        await bomRuns.updateStatus(get().currentRunId!, 'failed', undefined, errorMsg);
      }

      toast.error('Export failed: ' + errorMsg);
    }
  },

  cancelExport: () => {
    // TODO: Implement cancellation if export supports it
    set({ exporting: false, exportProgress: 0, exportStatus: '' });
    toast.info('Export cancelled');
  },

  loadRunHistory: async (packageScopeId) => {
    try {
      const history = await bomRuns.getByPackage(packageScopeId, 50);
      set({ runHistory: history });
    } catch (e) {
      toast.error('Failed to load run history');
    }
  },

  reRun: async (runId) => {
    try {
      const run = await bomRuns.getById(runId);
      if (!run) {
        toast.error('Run not found');
        return;
      }

      // TODO: Load input file, restore mapping, start export
      toast.info('Re-run functionality to be implemented');
    } catch (e) {
      toast.error('Failed to re-run job');
    }
  },

  deleteRun: async (runId) => {
    try {
      // TODO: Add delete function to db client
      toast.info('Delete functionality to be implemented');
    } catch (e) {
      toast.error('Failed to delete run');
    }
  },

  clearError: () => set({ error: null }),
}));
```
  </action>
  <verify>
Run: `npm run build`
  </verify>
  <done>
Store compiles and orchestrates export workflow with DB integration.
  </done>
</task>

<task type="auto">
  <name>Task 4: Build ExportProgressDialog component</name>
  <files>src/components/bom-translation/ExportProgressDialog.tsx</files>
  <action>
Create `ExportProgressDialog.tsx` with:

**UI:**
- Modal/Dialog showing export progress
- Progress bar with percentage
- Status message
- Current step indicator (Initialize → Generate → Record → Write → Complete)
- Success message with file location on completion
- Error display with retry/cancel buttons

**Props:**
- `open: boolean` - whether dialog is open
- `onClose: () => void` - close handler
- `onComplete: () => void` - completion callback

```tsx
import { useBOMExportStore } from '@/stores/bom-export-store';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { Progress } from '@/components/ui/progress';
import { Button } from '@/components/ui/button';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { CheckCircle2, XCircle, Loader2 } from 'lucide-react';

interface Props {
  open: boolean;
  onClose: () => void;
  onComplete: () => void;
}

export function ExportProgressDialog({ open, onClose, onComplete }: Props) {
  const { exporting, exportProgress, exportStatus, error } = useBOMExportStore();

  const handleClose = () => {
    if (!exporting) {
      onClose();
      if (!error) onComplete();
    }
  };

  return (
    <Dialog open={open} onOpenChange={handleClose}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Exporting BOM</DialogTitle>
        </DialogHeader>

        <div className="space-y-4">
          {exporting && (
            <>
              <div className="flex items-center gap-3">
                <Loader2 className="h-5 w-5 animate-spin" />
                <span className="font-medium">{exportStatus}</span>
              </div>

              <Progress value={exportProgress} className="h-2" />

              <div className="text-sm text-muted-foreground text-right">
                {exportProgress}%
              </div>
            </>
          )}

          {!exporting && !error && (
            <div className="flex items-center gap-3 text-green-600">
              <CheckCircle2 className="h-5 w-5" />
              <span className="font-medium">Export completed successfully</span>
            </div>
          )}

          {error && (
            <Alert variant="destructive">
              <XCircle className="h-4 w-4" />
              <AlertDescription>{error}</AlertDescription>
            </Alert>
          )}

          <div className="flex justify-end gap-2">
            {!exporting && (
              <Button onClick={handleClose}>
                {error ? 'Close' : 'Done'}
              </Button>
            )}
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
}
```
  </action>
  <verify>
Run: `npm run build` and `npm run lint`
  </verify>
  <done>
Dialog renders and shows export progress with proper states.
  </done>
</task>

<task type="auto">
  <name>Task 5: Build RunHistoryDialog component</name>
  <files>src/components/bom-translation/RunHistoryDialog.tsx</files>
  <action>
Create `RunHistoryDialog.tsx` with:

**UI:**
- Dialog showing run history table
- Columns: Date, Status, Input File, Mapping, Output Hash, Actions
- Status badges (Completed=green, Failed=red, Running=blue)
- "Re-run" button per row
- "Delete" button per row
- "View Details" button (shows full run metadata)
- Empty state when no history

**Props:**
- `open: boolean`
- `onClose: () => void`
- `packageScopeId: number`

```tsx
import { useEffect } from 'react';
import { useBOMExportStore } from '@/stores/bom-export-store';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';
import { formatDistanceToNow } from 'date-fns';
import { RotateCcw, Trash2, Eye } from 'lucide-react';

interface Props {
  open: boolean;
  onClose: () => void;
  packageScopeId: number;
}

export function RunHistoryDialog({ open, onClose, packageScopeId }: Props) {
  const { runHistory, loadRunHistory, reRun, deleteRun } = useBOMExportStore();

  useEffect(() => {
    if (open && packageScopeId) {
      loadRunHistory(packageScopeId);
    }
  }, [open, packageScopeId]);

  const getStatusBadge = (status: string) => {
    const variants = {
      completed: 'default',
      failed: 'destructive',
      running: 'outline',
      cancelled: 'secondary',
    } as const;

    return (
      <Badge variant={variants[status as keyof typeof variants] || 'secondary'}>
        {status}
      </Badge>
    );
  };

  return (
    <Dialog open={open} onOpenChange={onClose}>
      <DialogContent className="max-w-4xl max-h-[600px] overflow-auto">
        <DialogHeader>
          <DialogTitle>Run History</DialogTitle>
        </DialogHeader>

        {runHistory.length === 0 ? (
          <div className="text-center py-8 text-muted-foreground">
            No run history yet
          </div>
        ) : (
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>Date</TableHead>
                <TableHead>Status</TableHead>
                <TableHead>Input</TableHead>
                <TableHead>Output Hash</TableHead>
                <TableHead className="text-right">Actions</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {runHistory.map(run => (
                <TableRow key={run.id}>
                  <TableCell>
                    {formatDistanceToNow(new Date(run.started_at), { addSuffix: true })}
                  </TableCell>
                  <TableCell>{getStatusBadge(run.status)}</TableCell>
                  <TableCell className="font-mono text-sm">
                    {run.input_file_hash.slice(0, 8)}
                  </TableCell>
                  <TableCell className="font-mono text-sm">
                    {run.output_file_hash?.slice(0, 8) || '-'}
                  </TableCell>
                  <TableCell className="text-right">
                    <div className="flex justify-end gap-2">
                      <Button
                        variant="ghost"
                        size="sm"
                        onClick={() => reRun(run.id)}
                        disabled={run.status !== 'completed'}
                      >
                        <RotateCcw className="h-4 w-4" />
                      </Button>
                      <Button
                        variant="ghost"
                        size="sm"
                        onClick={() => deleteRun(run.id)}
                      >
                        <Trash2 className="h-4 w-4" />
                      </Button>
                    </div>
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        )}

        <div className="flex justify-end">
          <Button onClick={onClose}>Close</Button>
        </div>
      </DialogContent>
    </Dialog>
  );
}
```
  </action>
  <verify>
Run: `npm run build` and `npm run lint`
  </verify>
  <done>
Dialog renders and displays run history with actions.
  </done>
</task>

<task type="auto">
  <name>Task 6: Add export button and history dialog to BOM Translation page</name>
  <files>src/pages/bom-translation-page.tsx</files>
  <action>
Update the BOM Translation page to:

1. Add "Export" button in the review step (enabled only if validation passes)
2. Add "View History" button in the page header or toolbar
3. Wire up ExportProgressDialog and RunHistoryDialog
4. Pass current BOM data and mapping to export store

**Changes:**
- Import `useBOMExportStore`, `ExportProgressDialog`, `RunHistoryDialog`
- Add export button: `<Button onClick={() => startExport(rows, mapping, outputPath)} disabled={!validation.canExport}>Export to .zw1</Button>`
- Add history button: `<Button onClick={() => setShowHistory(true)} variant="outline">View History</Button>`
- Render dialogs at bottom of component
- Get output path from user via file dialog or default path

**File save dialog:**
```typescript
import { open } from '@tauri-apps/plugin-dialog';

const handleExportClick = async () => {
  const outputPath = await open({
    multiple: false,
    filters: [{
      name: 'ZW1 File',
      extensions: ['zw1']
    }]
  });

  if (outputPath) {
    startExport(rows, mapping, outputPath as string);
  }
};
```
  </action>
  <verify>
Run: `npm run build`
  </verify>
  <done>
Page has export and history buttons that trigger dialogs correctly.
  </done>
</task>

<task type="auto">
  <name>Task 7: Extend DB client with run deletion helper</name>
  <files>src/lib/db/client.ts</files>
  <action>
Add delete function to `bomRuns` in `src/lib/db/client.ts`:

```typescript
export const bomRuns = {
  // ... existing functions ...

  // Delete a run (cascades to input files)
  delete: (id: number) =>
    execute(`DELETE FROM bom_runs WHERE id = ?`, [id]),
};
```

Ensure cascade delete is configured in schema (already done in 02-01).
  </action>
  <verify>
Run: `npm run build`
  </verify>
  <done>
DB client provides run deletion helper.
  </done>
</task>

</tasks>

<verification>
- `npm run build` succeeds
- `npm run lint` succeeds
- Create a test BOM with valid data
- Verify export button is enabled when validation passes
- Click export, select output location, verify progress dialog shows steps
- Verify .zw1 file is created at selected location
- Verify run history shows the completed run
- Verify re-run button restores previous mapping and allows re-export
- Verify export is blocked when validation errors exist
- Verify hash mismatch error is shown if file write fails
- Verify run history persists across page reloads
</verification>

<success_criteria>
- User can export validated BOM to .zw1 format
- Export progress shows real-time status updates
- Exported file is deterministic (same input produces same output)
- Each export is recorded in run history with full metadata
- User can view history and re-run past jobs
- Export is blocked if validation errors exist
- History shows input/output hashes and timestamps
</success_criteria>

<output>
After completion, create `.planning/phases/02-bom-translation-release-rails/02-04-SUMMARY.md`
</output>
