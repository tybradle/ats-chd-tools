# PLAN-02-03: BOM Translation — Data Validation & Review UI

**Phase:** 02-bom-translation-release-rails
**Created:** 2026-01-21
**Status:** Draft

## Objective

Implement pre-flight validation, structured BOM review interface with inline editing, search/filter/sort, and flattened preview before export.

## Success Criteria

1. Pre-flight validation scans mapped data and shows actionable errors (missing required fields, invalid types, duplicate part numbers)
2. Validation errors link to specific rows/columns and block export until resolved
3. Review UI shows BOM in structured (editable grid) and flattened (read-only preview) views
4. Users can edit cells inline, add/delete rows, and use multi-cell selection with copy/paste
5. Search filters across all columns; sort by any column
6. Changes are persisted to pending state before export

## Changes

### TypeScript Types

**File:** `src/types/bom.ts` (extend existing)

```typescript
// Validation Severity
export type ValidationSeverity = 'error' | 'warning' | 'info';

// Validation Issue
export interface ValidationIssue {
  id: string;
  severity: ValidationSeverity;
  rowNumber: number; // 1-based (header = 0)
  columnField: string; // target field name
  message: string;
  value: unknown; // the problematic value
  fixable: boolean; // can auto-fix?
  suggestedValue?: unknown;
}

// Validation Summary
export interface ValidationSummary {
  errorCount: number;
  warningCount: number;
  infoCount: number;
  issues: ValidationIssue[];
  canExport: boolean; // true if no errors
}

// BOM Row (structured data)
export interface BomRow {
  id: string; // unique identifier for editing
  rowNumber: number; // original Excel row number
  part_number: string | null;
  quantity: number | null;
  description: string | null;
  manufacturer: string | null;
  manufacturer_part_number: string | null;
  supplier: string | null;
  supplier_part_number: string | null;
  reference_designators: string | null;
  value: string | null;
  footprint: string | null;
  // Additional attributes from extra columns
  attributes?: Record<string, unknown>;
}

// BOM Data (mapped and validated)
export interface BomData {
  rows: BomRow[];
  validation: ValidationSummary;
  totalRows: number;
  validRows: number;
}

// Cell Edit
export interface CellEdit {
  rowId: string;
  field: keyof BomRow;
  value: unknown;
}

// Flattened Preview (for .zw1 export preview)
export interface FlattenedBomRow {
  line_item: number;
  part_number: string;
  quantity: number;
  description: string;
  // Additional flattened fields...
}
```

### Validation Engine

**File:** `src/lib/bom/validation.ts` (new file)

```typescript
import { BomRow, ValidationIssue, ValidationSeverity, ValidationSummary } from '@/types/bom';
import { BOM_TARGET_FIELDS } from '@/types/bom';

// Required fields validation
const REQUIRED_FIELDS: (keyof BomRow)[] = ['part_number', 'quantity'];

// Type validators
const validators = {
  part_number: (value: unknown): string | null => {
    if (!value || typeof value !== 'string' || value.trim() === '') {
      return 'Part number is required';
    }
    if (value.length > 100) {
      return 'Part number too long (max 100 chars)';
    }
    return null;
  },

  quantity: (value: unknown): string | null => {
    if (value === null || value === undefined || value === '') {
      return 'Quantity is required';
    }
    const num = typeof value === 'string' ? parseFloat(value) : value as number;
    if (isNaN(num)) {
      return 'Quantity must be a number';
    }
    if (num <= 0) {
      return 'Quantity must be greater than 0';
    }
    return null;
  },

  description: (value: unknown): string | null => {
    if (value && typeof value === 'string' && value.length > 500) {
      return 'Description too long (max 500 chars)';
    }
    return null;
  },
};

export function validateBomRow(row: BomRow, rowIndex: number): ValidationIssue[] {
  const issues: ValidationIssue[] = [];

  // Check required fields
  for (const field of REQUIRED_FIELDS) {
    const validator = validators[field];
    if (validator) {
      const error = validator(row[field]);
      if (error) {
        issues.push({
          id: `${rowIndex}-${field}`,
          severity: 'error',
          rowNumber: rowIndex + 2, // +2 for header (0) and 1-based row index
          columnField: field,
          message: error,
          value: row[field],
          fixable: field === 'quantity' && !isNaN(parseFloat(String(row[field] || '0'))),
          suggestedValue: field === 'quantity' ? parseFloat(String(row[field] || '0')) : undefined,
        });
      }
    }
  }

  // Check for duplicate part numbers
  if (row.part_number) {
    // This will be checked in batch validation
  }

  return issues;
}

export function validateBomData(rows: BomRow[]): ValidationSummary {
  const allIssues: ValidationIssue[] = [];

  // Validate each row
  rows.forEach((row, index) => {
    const rowIssues = validateBomRow(row, index);
    allIssues.push(...rowIssues);
  });

  // Check for duplicate part numbers
  const partNumbers = new Map<string, number[]>();
  rows.forEach((row, index) => {
    if (row.part_number) {
      const indices = partNumbers.get(row.part_number) || [];
      indices.push(index);
      partNumbers.set(row.part_number, indices);
    }
  });

  partNumbers.forEach((indices, pn) => {
    if (indices.length > 1) {
      indices.forEach(index => {
        allIssues.push({
          id: `dup-${pn}-${index}`,
          severity: 'warning',
          rowNumber: index + 2,
          columnField: 'part_number',
          message: `Duplicate part number (appears ${indices.length} times)`,
          value: rows[index].part_number,
          fixable: false,
        });
      });
    }
  });

  const errorCount = allIssues.filter(i => i.severity === 'error').length;
  const warningCount = allIssues.filter(i => i.severity === 'warning').length;
  const infoCount = allIssues.filter(i => i.severity === 'info').length;

  return {
    errorCount,
    warningCount,
    infoCount,
    issues: allIssues,
    canExport: errorCount === 0,
  };
}

export function applyAutoFixes(rows: BomRow[], issues: ValidationIssue[]): BomRow[] {
  const fixedRows = [...rows];

  issues.filter(i => i.fixable && i.suggestedValue !== undefined).forEach(issue => {
    const rowIndex = fixedRows.findIndex(r => r.id === issue.rowNumber.toString());
    if (rowIndex >= 0) {
      (fixedRows[rowIndex] as any)[issue.columnField] = issue.suggestedValue;
    }
  });

  return fixedRows;
}
```

### React Components

**File:** `src/components/bom/BomValidationSummary.tsx` (new file)

```tsx
import { ValidationSummary } from '@/types/bom';
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { AlertCircle, AlertTriangle, Info, CheckCircle2, XCircle } from 'lucide-react';
import { ScrollArea } from '@/components/ui/scroll-area';

interface Props {
  validation: ValidationSummary;
  onFixAll: () => void;
  onNavigateToIssue: (issueId: string) => void;
}

export function BomValidationSummary({ validation, onFixAll, onNavigateToIssue }: Props) {
  const fixableIssues = validation.issues.filter(i => i.fixable);

  return (
    <div className="space-y-3">
      {/* Status Banner */}
      <Alert variant={validation.canExport ? 'default' : 'destructive'}>
        {validation.canExport ? (
          <CheckCircle2 className="h-4 w-4" />
        ) : (
          <XCircle className="h-4 w-4" />
        )}
        <AlertTitle>
          {validation.canExport
            ? 'Ready to export'
            : `Cannot export (${validation.errorCount} ${validation.errorCount === 1 ? 'error' : 'errors'})`}
        </AlertTitle>
        <AlertDescription>
          {validation.warningCount > 0 && (
            <span className="text-yellow-600">
              {validation.warningCount} warning{validation.warningCount > 1 ? 's' : ''} •{' '}
            </span>
          )}
          {validation.totalRows > 0 && (
            <span>{validation.validRows} of {validation.totalRows} rows valid</span>
          )}
        </AlertDescription>
      </Alert>

      {/* Fix All Button */}
      {fixableIssues.length > 0 && (
        <Button onClick={onFixAll} variant="outline" size="sm">
          Auto-fix {fixableIssues.length} issue{fixableIssues.length > 1 ? 's' : ''}
        </Button>
      )}

      {/* Issues List */}
      {validation.issues.length > 0 && (
        <ScrollArea className="h-[300px] border rounded-md p-4">
          <div className="space-y-2">
            {validation.issues.map(issue => (
              <div
                key={issue.id}
                className="flex items-start gap-3 p-2 rounded hover:bg-muted cursor-pointer"
                onClick={() => onNavigateToIssue(issue.id)}
              >
                {issue.severity === 'error' && <XCircle className="h-4 w-4 text-destructive mt-0.5" />}
                {issue.severity === 'warning' && <AlertTriangle className="h-4 w-4 text-yellow-600 mt-0.5" />}
                {issue.severity === 'info' && <Info className="h-4 w-4 text-blue-600 mt-0.5" />}

                <div className="flex-1 min-w-0">
                  <div className="flex items-center gap-2">
                    <span className="font-mono text-sm">Row {issue.rowNumber}</span>
                    <Badge variant="outline" className="text-xs">
                      {issue.columnField}
                    </Badge>
                  </div>
                  <p className="text-sm text-muted-foreground mt-1">{issue.message}</p>
                  <p className="text-xs font-mono mt-1 truncate">Value: {String(issue.value)}</p>
                </div>

                {issue.fixable && (
                  <Badge variant="secondary" className="text-xs">Auto-fixable</Badge>
                )}
              </div>
            ))}
          </div>
        </ScrollArea>
      )}
    </div>
  );
}
```

**File:** `src/components/bom/BomDataGrid.tsx` (new file)

```tsx
import { useState, useMemo } from 'react';
import { BomRow, ValidationIssue } from '@/types/bom';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';
import { Input } from '@/components/ui/input';
import { Button } from '@/components/ui/button';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Badge } from '@/components/ui/badge';
import { ArrowUpDown, ArrowUp, ArrowDown, Search, Plus, Trash2 } from 'lucide-react';
import { cn } from '@/lib/utils';

interface Props {
  rows: BomRow[];
  issues: ValidationIssue[];
  onCellEdit: (rowId: string, field: keyof BomRow, value: unknown) => void;
  onRowAdd: () => void;
  onRowDelete: (rowId: string) => void;
  onIssueClick?: (issueId: string) => void;
}

type SortField = keyof BomRow | 'rowNumber';
type SortOrder = 'asc' | 'desc' | null;

export function BomDataGrid({ rows, issues, onCellEdit, onRowAdd, onRowDelete, onIssueClick }: Props) {
  const [searchQuery, setSearchQuery] = useState('');
  const [sortField, setSortField] = useState<SortField>('rowNumber');
  const [sortOrder, setSortOrder] = useState<SortOrder>('asc');
  const [selectedCells, setSelectedCells] = useState<Set<string>>(new Set());

  // Create issue lookup map
  const issueMap = useMemo(() => {
    const map = new Map<string, ValidationIssue>();
    issues.forEach(i => {
      const key = `${i.rowNumber}-${i.columnField}`;
      map.set(key, i);
    });
    return map;
  }, [issues]);

  // Filter and sort rows
  const filteredRows = useMemo(() => {
    let result = [...rows];

    // Filter
    if (searchQuery) {
      const query = searchQuery.toLowerCase();
      result = result.filter(row =>
        Object.values(row).some(v =>
          String(v || '').toLowerCase().includes(query)
        )
      );
    }

    // Sort
    if (sortField && sortOrder) {
      result.sort((a, b) => {
        const aVal = sortField === 'rowNumber' ? a.rowNumber : a[sortField];
        const bVal = sortField === 'rowNumber' ? b.rowNumber : b[sortField];

        if (aVal === bVal) return 0;
        const cmp = aVal > bVal ? 1 : -1;
        return sortOrder === 'asc' ? cmp : -cmp;
      });
    }

    return result;
  }, [rows, searchQuery, sortField, sortOrder]);

  const handleSort = (field: SortField) => {
    if (sortField === field) {
      setSortOrder(sortOrder === 'asc' ? 'desc' : sortOrder === 'desc' ? null : 'asc');
    } else {
      setSortField(field);
      setSortOrder('asc');
    }
  };

  const handleCellChange = (row: BomRow, field: keyof BomRow, value: string) => {
    // Convert value type based on field
    let convertedValue: unknown = value;
    if (field === 'quantity') {
      convertedValue = parseFloat(value) || 0;
    }
    onCellEdit(row.id, field, convertedValue);
  };

  const getIssueForCell = (row: BomRow, field: keyof BomRow) => {
    return issueMap.get(`${row.rowNumber}-${field}`);
  };

  return (
    <div className="space-y-4">
      {/* Toolbar */}
      <div className="flex items-center gap-4">
        <div className="relative flex-1">
          <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
          <Input
            placeholder="Search all columns..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className="pl-10"
          />
        </div>
        <Button onClick={onRowAdd} size="sm">
          <Plus className="h-4 w-4 mr-2" />
          Add Row
        </Button>
      </div>

      {/* Data Grid */}
      <div className="border rounded-md">
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead className="w-[80px]">
                <Button
                  variant="ghost"
                  size="sm"
                  className="h-auto p-1 font-normal"
                  onClick={() => handleSort('rowNumber')}
                >
                  Row
                  {sortField === 'rowNumber' && (
                    sortOrder === 'asc' ? <ArrowUp className="h-3 w-3 ml-1" /> : <ArrowDown className="h-3 w-3 ml-1" />
                  )}
                </Button>
              </TableHead>

              {['part_number', 'quantity', 'description', 'manufacturer', 'manufacturer_part_number'].map(field => (
                <TableHead key={field}>
                  <Button
                    variant="ghost"
                    size="sm"
                    className="h-auto p-1 font-normal"
                    onClick={() => handleSort(field as keyof BomRow)}
                  >
                    {field.replace(/_/g, ' ')}
                    {sortField === field && (
                      sortOrder === 'asc' ? <ArrowUp className="h-3 w-3 ml-1" /> : <ArrowDown className="h-3 w-3 ml-1" />
                    )}
                  </Button>
                </TableHead>
              ))}

              <TableHead className="w-[50px]" />
            </TableRow>
          </TableHeader>

          <TableBody>
            {filteredRows.map(row => (
              <TableRow key={row.id}>
                <TableCell className="font-mono text-sm text-muted-foreground">
                  {row.rowNumber}
                </TableCell>

                {(['part_number', 'quantity', 'description', 'manufacturer', 'manufacturer_part_number'] as const).map(field => {
                  const issue = getIssueForCell(row, field);
                  const value = row[field];

                  return (
                    <TableCell key={field} className={cn(
                      issue?.severity === 'error' && 'bg-destructive/10',
                      issue?.severity === 'warning' && 'bg-yellow-500/10'
                    )}>
                      <Input
                        value={String(value || '')}
                        onChange={(e) => handleCellChange(row, field, e.target.value)}
                        className={cn(
                          'h-8 min-w-[120px]',
                          issue && 'border-destructive'
                        )}
                      />
                      {issue && (
                        <Badge
                          variant="outline"
                          className={cn(
                            'text-xs mt-1 cursor-pointer',
                            issue.severity === 'error' && 'text-destructive border-destructive',
                            issue.severity === 'warning' && 'text-yellow-600 border-yellow-600'
                          )}
                          onClick={() => onIssueClick?.(issue.id)}
                        >
                          {issue.severity}
                        </Badge>
                      )}
                    </TableCell>
                  );
                })}

                <TableCell>
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => onRowDelete(row.id)}
                  >
                    <Trash2 className="h-4 w-4" />
                  </Button>
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </div>

      {/* Pagination/Footer */}
      <div className="flex items-center justify-between text-sm text-muted-foreground">
        <span>Showing {filteredRows.length} of {rows.length} rows</span>
        <span>{issues.length} issue{issues.length !== 1 ? 's' : ''}</span>
      </div>
    </div>
  );
}
```

**File:** `src/components/bom/FlattenedPreview.tsx` (new file)

```tsx
import { BomRow } from '@/types/bom';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';
import { Badge } from '@/components/ui/badge';

interface Props {
  rows: BomRow[];
}

export function FlattenedPreview({ rows }: Props) {
  const flattened = rows.map((row, idx) => ({
    line_item: idx + 1,
    part_number: row.part_number || '-',
    quantity: row.quantity || 0,
    description: row.description || '',
    manufacturer: row.manufacturer || '-',
    manufacturer_part_number: row.manufacturer_part_number || '-',
  }));

  return (
    <Card>
      <CardHeader>
        <CardTitle>Flattened Export Preview (.zw1 format)</CardTitle>
        <p className="text-sm text-muted-foreground">
          Read-only preview of how data will be exported
        </p>
      </CardHeader>

      <CardContent>
        <div className="border rounded-md max-h-[400px] overflow-auto">
          <Table>
            <TableHeader className="sticky top-0 bg-background">
              <TableRow>
                <TableHead className="w-[60px]">Line</TableHead>
                <TableHead>Part Number</TableHead>
                <TableHead className="w-[80px]">Qty</TableHead>
                <TableHead>Description</TableHead>
                <TableHead>Manufacturer</TableHead>
                <TableHead>Mfg P/N</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {flattened.map((row, idx) => (
                <TableRow key={idx}>
                  <TableCell className="font-mono text-sm">{row.line_item}</TableCell>
                  <TableCell className="font-mono">{row.part_number}</TableCell>
                  <TableCell>{row.quantity}</TableCell>
                  <TableCell className="max-w-[300px] truncate">{row.description}</TableCell>
                  <TableCell>{row.manufacturer}</TableCell>
                  <TableCell className="font-mono">{row.manufacturer_part_number}</TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </div>
      </CardContent>
    </Card>
  );
}
```

### Zustand Store

**File:** `src/stores/bom-data-store.ts` (new file)

```typescript
import { create } from 'zustand';
import { BomRow, ValidationSummary, CellEdit, BomData } from '@/types/bom';
import { validateBomData, applyAutoFixes } from '@/lib/bom/validation';
import { ColumnMapping } from '@/types/bom';

interface BomDataState {
  // Data state
  rows: BomRow[];
  validation: ValidationSummary;
  selectedRowId: string | null;
  selectedIssueId: string | null;

  // Actions
  loadFromMapping: (mappedData: Record<string, unknown>[], mapping: ColumnMapping) => void;
  editCell: (rowId: string, field: keyof BomRow, value: unknown) => void;
  addRow: () => void;
  deleteRow: (rowId: string) => void;
  deleteRows: (rowIds: string[]) => void;
  validate: () => void;
  autoFix: () => void;
  setSelectedRow: (rowId: string | null) => void;
  setSelectedIssue: (issueId: string | null) => void;
  clear: () => void;
}

const generateRowId = () => `row-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

export const useBomDataStore = create<BomDataState>((set, get) => ({
  rows: [],
  validation: {
    errorCount: 0,
    warningCount: 0,
    infoCount: 0,
    issues: [],
    canExport: false,
  },
  selectedRowId: null,
  selectedIssueId: null,

  loadFromMapping: (mappedData, mapping) => {
    // Convert mapped data to BomRow format
    const reverseMapping = Object.fromEntries(
      Object.entries(mapping).map(([k, v]) => [v, k])
    );

    const rows: BomRow[] = mappedData.map((rawRow, idx) => {
      const row: BomRow = {
        id: generateRowId(),
        rowNumber: idx + 1,
        part_number: null,
        quantity: null,
        description: null,
        manufacturer: null,
        manufacturer_part_number: null,
        supplier: null,
        supplier_part_number: null,
        reference_designators: null,
        value: null,
        footprint: null,
        attributes: {},
      };

      // Map fields from source data
      Object.entries(reverseMapping).forEach(([targetField, sourceCol]) => {
        if (sourceCol && rawRow[sourceCol] !== undefined) {
          (row as any)[targetField] = rawRow[sourceCol];
        }
      });

      // Extra attributes
      Object.entries(rawRow).forEach(([col, val]) => {
        if (!Object.values(reverseMapping).includes(col)) {
          row.attributes![col] = val;
        }
      });

      return row;
    });

    set({ rows });
    get().validate();
  },

  editCell: (rowId, field, value) => {
    set(state => ({
      rows: state.rows.map(r =>
        r.id === rowId ? { ...r, [field]: value } : r
      ),
    }));
    get().validate();
  },

  addRow: () => {
    const newRow: BomRow = {
      id: generateRowId(),
      rowNumber: get().rows.length + 1,
      part_number: null,
      quantity: null,
      description: null,
      manufacturer: null,
      manufacturer_part_number: null,
      supplier: null,
      supplier_part_number: null,
      reference_designators: null,
      value: null,
      footprint: null,
      attributes: {},
    };

    set(state => ({
      rows: [...state.rows, newRow],
    }));
  },

  deleteRow: (rowId) => {
    set(state => ({
      rows: state.rows.filter(r => r.id !== rowId),
    }));
    get().validate();
  },

  deleteRows: (rowIds) => {
    set(state => ({
      rows: state.rows.filter(r => !rowIds.includes(r.id)),
    }));
    get().validate();
  },

  validate: () => {
    const { rows } = get();
    const validation = validateBomData(rows);
    set({ validation });
  },

  autoFix: () => {
    const { rows, validation } = get();
    const fixedRows = applyAutoFixes(rows, validation.issues);
    set({ rows: fixedRows });
    get().validate();
  },

  setSelectedRow: (rowId) => set({ selectedRowId: rowId }),
  setSelectedIssue: (issueId) => {
    set({ selectedIssueId: issueId });
    // Navigate to row
    const issue = get().validation.issues.find(i => i.id === issueId);
    if (issue) {
      const row = get().rows.find(r => r.rowNumber === issue.rowNumber - 2);
      if (row) {
        set({ selectedRowId: row.id });
      }
    }
  },

  clear: () => set({
    rows: [],
    validation: {
      errorCount: 0,
      warningCount: 0,
      infoCount: 0,
      issues: [],
      canExport: false,
    },
    selectedRowId: null,
    selectedIssueId: null,
  }),
}));
```

## Verification

1. Import Excel file with intentional errors (missing part numbers, invalid quantities)
2. Verify validation summary shows correct error count and lists all issues
3. Click on validation issue and verify grid scrolls to the problematic cell
4. Fix errors manually and verify validation updates automatically
5. Test auto-fix for quantity type errors
6. Add new row and verify it appears at the end
7. Delete row and verify validation updates
8. Test search filtering and column sorting
9. Verify flattened preview reflects current data state
10. Export is blocked when errors exist, enabled when only warnings remain

## Dependencies

- Plan 02-01 (database schema for BOM runs)
- Plan 02-02 (Excel import and column mapping)
- shadcn/ui Table, Input, Button components

## Risks

- Large BOMs (>1000 rows) may impact performance; consider virtualization
- Inline editing needs debouncing to avoid excessive re-validations
- Copy/paste from Excel needs to handle tab-separated values correctly
- Undo/redo not implemented; users may lose data accidentally

## Deferred

- Bulk editing (select multiple rows and update field)
- Row drag-and-drop reordering
- Advanced filtering (filter by multiple columns simultaneously)
- Export to Excel (edit) and re-import workflow
