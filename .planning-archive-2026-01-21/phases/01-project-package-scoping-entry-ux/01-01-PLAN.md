---
phase: 01-project-package-scoping-entry-ux
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/migrations/004_project_package_scoping.sql
  - src-tauri/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "User can have multiple Packages under the same Job Project (job #)"
    - "User cannot create two Packages with the same name within the same Job Project"
  artifacts:
    - path: "src-tauri/migrations/004_project_package_scoping.sql"
      provides: "SQLite migration introducing bom_job_projects + bom_packages and rewiring BOM tables"
      contains: "CREATE TABLE IF NOT EXISTS bom_job_projects"
    - path: "src-tauri/src/lib.rs"
      provides: "Tauri SQL plugin runs migration v4"
      contains: "version: 4"
  key_links:
    - from: "src-tauri/src/lib.rs"
      to: "src-tauri/migrations/004_project_package_scoping.sql"
      via: "include_str! + add_migrations"
      pattern: "include_str!\(\"../migrations/004_project_package_scoping\\.sql\"\)"
---

<objective>
Introduce a durable Project(job #) â†’ Package schema in SQLite while preserving existing BOM scope IDs.

Purpose: Enable multiple Packages per job without breaking existing BOM data relationships.
Output: A new migration (v4) and Tauri wiring to apply it.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-project-package-scoping-entry-ux/01-CONTEXT.md
@.planning/phases/01-project-package-scoping-entry-ux/01-RESEARCH.md

@src-tauri/migrations/002_bom_tables.sql
@src-tauri/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add migration v4 for Project(job#) + Packages and rewire FKs</name>
  <files>src-tauri/migrations/004_project_package_scoping.sql</files>
  <action>
Create `004_project_package_scoping.sql` to evolve the BOM schema from a single `bom_projects` scope table into:

- `bom_job_projects` (job # projects; `project_number` UNIQUE)
- `bom_packages` (packages scoped to a job project; `UNIQUE(project_id, package_name)`)

Hard requirement: preserve existing scope IDs by copying `bom_projects_old.id` into `bom_packages.id`.

Migration strategy (SQLite-safe; rebuild tables to change FK targets):
1) Wrap migration in a transaction; temporarily disable FK enforcement during table rebuild.
2) `ALTER TABLE bom_projects RENAME TO bom_projects_old;`
3) Create `bom_job_projects` and `bom_packages`.
4) Backfill `bom_job_projects`:
   - Insert distinct `project_number` values from `bom_projects_old`.
5) Backfill `bom_packages` preserving ids:
   - `INSERT INTO bom_packages(id, project_id, package_name, name, description, version, metadata, created_at, updated_at)
      SELECT old.id, p.id, old.package_name, old.name, old.description, old.version, old.metadata, old.created_at, old.updated_at
      FROM bom_projects_old old
      JOIN bom_job_projects p ON p.project_number = old.project_number;`
6) Rebuild dependent tables so their `project_id` FK points to `bom_packages(id)` (keep column name `project_id` unchanged):
   - `bom_locations`
   - `bom_items`
   - `bom_exports`

Concrete rebuild pattern per table:
- `ALTER TABLE <table> RENAME TO <table>_old;`
- `CREATE TABLE <table> (...)` with the same columns/indexes but FK `project_id REFERENCES bom_packages(id) ON DELETE CASCADE`
- `INSERT INTO <table>(...) SELECT ... FROM <table>_old;`
- `DROP TABLE <table>_old;`

7) Add indexes equivalent to those in `002_bom_tables.sql` (especially for `bom_items(project_id)`, `bom_locations(project_id)`, etc.).
8) Drop `bom_projects_old` once all copies succeed.

Notes:
- Keep existing `bom_locations` uniqueness as `UNIQUE(project_id, name)` where `project_id` is now package id.
- Do NOT change BOM item/location/export column names in this migration; code refactor comes in later plans.
  </action>
  <verify>
Validate BOTH fresh install and upgrade-path behavior.

### A) Fresh DB boot
1) `npm run db:reset`
2) `npm run tauri:dev`
   - Confirm app boots without SQL migration errors.

### B) Deterministic upgrade test (v3 -> v4) with ID preservation

Goal: create a v3 database deterministically, seed it, then start the app so migrations upgrade to v4, and assert:
- `bom_packages.id` preserves the prior `bom_projects.id`
- all dependent `project_id` foreign keys remain valid

Steps (bash):
1) Ensure clean slate:
   - `npm run db:reset`

2) Generate deterministic seed SQL (repo script):
   - `npm run db:seed:bom`  # outputs `src-tauri/scripts/seed_bom_data.sql`

3) Create a v3 DB using SQLite CLI (same approach as CI workflow):
   - `mkdir -p src-tauri/test-db`
   - `SQLITE_VERSION="3470200"`
   - `curl -L "https://www.sqlite.org/2024/sqlite-tools-win-x64-${SQLITE_VERSION}.zip" -o sqlite.zip`
   - `unzip -q sqlite.zip`
   - `SQLITE_DIR="sqlite-tools-win-x64-${SQLITE_VERSION}"`
   - `SQLITE3="./${SQLITE_DIR}/sqlite3.exe"`
   - `V3_DB="src-tauri/test-db/ats-chd-tools-v3.db"`
   - `$SQLITE3 "$V3_DB" < src-tauri/migrations/001_initial.sql`
   - `$SQLITE3 "$V3_DB" < src-tauri/migrations/002_bom_tables.sql`
   - `$SQLITE3 "$V3_DB" < src-tauri/migrations/003_glenair_tables.sql`
   - `$SQLITE3 "$V3_DB" < src-tauri/scripts/seed_bom_data.sql`

4) Snapshot v3 scope IDs:
   - `$SQLITE3 "$V3_DB" "SELECT id FROM bom_projects ORDER BY id;" > /tmp/bom_project_ids.txt`

5) Copy v3 DB into the app's expected location:
   - `DB_PATH=$(node -e "const path=require('path'); const IDENTIFIER='com.ats.chd-tools'; const DB_NAME='ats-chd-tools.db'; console.log(path.join(process.env.LOCALAPPDATA||'', IDENTIFIER, DB_NAME));")`
   - `mkdir -p "$(dirname "$DB_PATH")"`
   - `cp "$V3_DB" "$DB_PATH"`

6) Run migrations by starting the app:
   - `npm run tauri:dev`
   - Confirm app boots without SQL migration errors.

7) Assert schema + ID preservation + FK integrity (must pass):
   - `$SQLITE3 "$DB_PATH" "SELECT name FROM sqlite_master WHERE type='table' AND name IN ('bom_job_projects','bom_packages','bom_items','bom_locations','bom_exports');"`
     - Expect at least `bom_job_projects` and `bom_packages` to exist.
   - `$SQLITE3 "$DB_PATH" "SELECT id FROM bom_packages ORDER BY id;" > /tmp/bom_package_ids.txt`
   - `diff -u /tmp/bom_project_ids.txt /tmp/bom_package_ids.txt`
     - Expect no diff output (IDs preserved 1:1).
   - `$SQLITE3 "$DB_PATH" "PRAGMA foreign_keys=ON; PRAGMA foreign_key_check;"`
     - Expect zero rows.
   - `$SQLITE3 "$DB_PATH" "SELECT COUNT(*) FROM bom_locations l LEFT JOIN bom_packages p ON p.id=l.project_id WHERE p.id IS NULL;"`
     - Expect `0`
   - `$SQLITE3 "$DB_PATH" "SELECT COUNT(*) FROM bom_items i LEFT JOIN bom_packages p ON p.id=i.project_id WHERE p.id IS NULL;"`
     - Expect `0`
   - `$SQLITE3 "$DB_PATH" "SELECT COUNT(*) FROM bom_exports e LEFT JOIN bom_packages p ON p.id=e.project_id WHERE p.id IS NULL;"`
     - Expect `0`
  </verify>
  <done>
Migration v4 is safe for both scenarios:
- Fresh DB: app boots and schema contains `bom_job_projects` + `bom_packages` and dependent tables reference `bom_packages(id)`.
- Upgrade DB (pre-v4/v3 seeded DB): after running the app, `bom_packages.id` exactly matches the prior `bom_projects.id` values, and `PRAGMA foreign_key_check` reports no violations (no orphan `project_id` rows in `bom_locations`, `bom_items`, `bom_exports`).
  </done>
</task>

<task type="auto">
  <name>Task 2: Register migration v4 in Tauri startup</name>
  <files>src-tauri/src/lib.rs</files>
  <action>
Update the `migrations` vector to include a new `Migration { version: 4, description: "Project/Package scoping (job projects + packages)", sql: include_str!("../migrations/004_project_package_scoping.sql"), kind: MigrationKind::Up }`.
  </action>
  <verify>
Run: `npm run tauri:dev` and confirm migration list includes version 4 (no compile errors).
  </verify>
  <done>
Tauri SQL plugin applies migration v4 on startup.
  </done>
</task>

</tasks>

<verification>
- App starts in Tauri dev mode without SQL errors.
</verification>

<success_criteria>
- SQLite schema supports multiple packages per job via `bom_job_projects` + `bom_packages`.
- Existing BOM data can be migrated without losing referential integrity (IDs preserved).
</success_criteria>

<output>
After completion, create `.planning/phases/01-project-package-scoping-entry-ux/01-01-SUMMARY.md`
</output>
