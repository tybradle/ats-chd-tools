---
phase: 01-project-package-scoping-entry-ux
plan: 07
type: execute
wave: 6
depends_on:
  - 01-03
files_modified:
  - src/stores/bom-store.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "User can switch Package scope reliably, even when there are pending writes"
    - "Scope switching cannot hang indefinitely; it either completes or fails fast with an error"
  artifacts:
    - path: "src/stores/bom-store.ts"
      provides: "Safe flushPendingWrites implementation used by setScope"
      contains: "flushPendingWrites"
  key_links:
    - from: "src/stores/bom-store.ts"
      to: "setScope"
      via: "await flushPendingWrites()"
      pattern: "await\s+flushPendingWrites\(\)"
---

<objective>
Close verification gap: eliminate a potential infinite loop/hang in `flushPendingWrites()` so scope switching cannot deadlock.

Purpose: Preserve “reliably enter and switch context” under real-world timing/race conditions.
Output: A terminating, time-bounded pending-writes flush with safe error handling.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/01-project-package-scoping-entry-ux/01-project-package-scoping-entry-ux-VERIFICATION.md

@src/stores/bom-store.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite flushPendingWrites to re-check state and guarantee termination</name>
  <files>src/stores/bom-store.ts</files>
  <action>
Fix the issue described in `01-project-package-scoping-entry-ux-VERIFICATION.md`:

- Locate `flushPendingWrites()`.
- Remove any implementation that captures `const state = get()` and then loops on `while (state.pendingWrites > 0)`.

Implement a safe strategy that MUST terminate:

Option A (preferred): Set-of-promises tracking
- Replace `pendingWrites: number` with:
  - `pendingWritePromises: Set<Promise<unknown>>`
- Provide helper `trackWrite(p: Promise<unknown>)` that adds p to the set and removes it in `.finally()`.
- `flushPendingWrites()` awaits `Promise.race([Promise.allSettled([...set]), timeoutPromise])`.

Option B (acceptable): counter + periodic re-check
- Keep `pendingWrites: number`, but loop by repeatedly re-reading `get().pendingWrites` each iteration.
- Include a max-wait timeout (e.g., 5s) and a short delay between checks (e.g., 25-50ms).

Timeout / escape hatch behavior (required for both options):
- If the flush exceeds the timeout, set store `error` to a clear message like "Pending writes did not complete; scope switch aborted" and proceed in a defined way:
  - Preferred: abort the scope switch (do not load new scope) and keep UI stable.
  - Acceptable: proceed with scope switch but also surface error (riskier; only do if existing UI needs it).

Non-goals:
- Do not introduce new persistence tables.
- Do not add UI components here; keep this limited to store behavior.
  </action>
  <verify>
Run: `npm run build`

Optional deterministic check (if store has unit tests already): run existing test suite.
  </verify>
  <done>
`flushPendingWrites()` cannot spin forever; it either completes when writes settle or exits via timeout with a store error.
  </done>
</task>

</tasks>

<verification>
- `npm run build` succeeds.
- Static inspection: no loops use a captured `state` snapshot for a changing condition.
</verification>

<success_criteria>
- Phase 1 truth: “User can switch Package scope reliably” is now achievable without risk of hanging the app.
</success_criteria>

<output>
After completion, create `.planning/phases/01-project-package-scoping-entry-ux/01-07-SUMMARY.md`
</output>
