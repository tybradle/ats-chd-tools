---
phase: 01-project-package-scoping-entry-ux
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/migrations/004_project_package_scoping.sql
  - src-tauri/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "A Project (job #) can contain multiple Packages"
    - "Package names are unique within a Project"
  artifacts:
    - path: "src-tauri/migrations/004_project_package_scoping.sql"
      provides: "SQLite migration introducing bom_job_projects + bom_packages and rewiring BOM tables"
      contains: "CREATE TABLE IF NOT EXISTS bom_job_projects"
    - path: "src-tauri/src/lib.rs"
      provides: "Tauri SQL plugin runs migration v4"
      contains: "version: 4"
  key_links:
    - from: "src-tauri/src/lib.rs"
      to: "src-tauri/migrations/004_project_package_scoping.sql"
      via: "include_str! + add_migrations"
      pattern: "include_str!\(\"../migrations/004_project_package_scoping\\.sql\"\)"
---

<objective>
Introduce a durable Project(job #) â†’ Package schema in SQLite while preserving existing BOM scope IDs.

Purpose: Enable multiple Packages per job without breaking existing BOM data relationships.
Output: A new migration (v4) and Tauri wiring to apply it.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-project-package-scoping-entry-ux/01-CONTEXT.md
@.planning/phases/01-project-package-scoping-entry-ux/01-RESEARCH.md

@src-tauri/migrations/002_bom_tables.sql
@src-tauri/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add migration v4 for Project(job#) + Packages and rewire FKs</name>
  <files>src-tauri/migrations/004_project_package_scoping.sql</files>
  <action>
Create `004_project_package_scoping.sql` to evolve the BOM schema from a single `bom_projects` scope table into:

- `bom_job_projects` (job # projects; `project_number` UNIQUE)
- `bom_packages` (packages scoped to a job project; `UNIQUE(project_id, package_name)`)

Hard requirement: preserve existing scope IDs by copying `bom_projects_old.id` into `bom_packages.id`.

Migration strategy (SQLite-safe; rebuild tables to change FK targets):
1) Wrap migration in a transaction; temporarily disable FK enforcement during table rebuild.
2) `ALTER TABLE bom_projects RENAME TO bom_projects_old;`
3) Create `bom_job_projects` and `bom_packages`.
4) Backfill `bom_job_projects`:
   - Insert distinct `project_number` values from `bom_projects_old`.
5) Backfill `bom_packages` preserving ids:
   - `INSERT INTO bom_packages(id, project_id, package_name, name, description, version, metadata, created_at, updated_at)
      SELECT old.id, p.id, old.package_name, old.name, old.description, old.version, old.metadata, old.created_at, old.updated_at
      FROM bom_projects_old old
      JOIN bom_job_projects p ON p.project_number = old.project_number;`
6) Rebuild dependent tables so their `project_id` FK points to `bom_packages(id)` (keep column name `project_id` unchanged):
   - `bom_locations`
   - `bom_items`
   - `bom_exports`

Concrete rebuild pattern per table:
- `ALTER TABLE <table> RENAME TO <table>_old;`
- `CREATE TABLE <table> (...)` with the same columns/indexes but FK `project_id REFERENCES bom_packages(id) ON DELETE CASCADE`
- `INSERT INTO <table>(...) SELECT ... FROM <table>_old;`
- `DROP TABLE <table>_old;`

7) Add indexes equivalent to those in `002_bom_tables.sql` (especially for `bom_items(project_id)`, `bom_locations(project_id)`, etc.).
8) Drop `bom_projects_old` once all copies succeed.

Notes:
- Keep existing `bom_locations` uniqueness as `UNIQUE(project_id, name)` where `project_id` is now package id.
- Do NOT change BOM item/location/export column names in this migration; code refactor comes in later plans.
  </action>
  <verify>
Run: `npm run tauri:dev` and confirm the app boots without SQL migration errors in the console/log.
  </verify>
  <done>
`004_project_package_scoping.sql` exists and (on a fresh DB) results in tables `bom_job_projects` + `bom_packages` and BOM dependent tables referencing `bom_packages(id)`.
  </done>
</task>

<task type="auto">
  <name>Task 2: Register migration v4 in Tauri startup</name>
  <files>src-tauri/src/lib.rs</files>
  <action>
Update the `migrations` vector to include a new `Migration { version: 4, description: "Project/Package scoping (job projects + packages)", sql: include_str!("../migrations/004_project_package_scoping.sql"), kind: MigrationKind::Up }`.
  </action>
  <verify>
Run: `npm run tauri:dev` and confirm migration list includes version 4 (no compile errors).
  </verify>
  <done>
Tauri SQL plugin applies migration v4 on startup.
  </done>
</task>

</tasks>

<verification>
- App starts in Tauri dev mode without SQL errors.
</verification>

<success_criteria>
- SQLite schema supports multiple packages per job via `bom_job_projects` + `bom_packages`.
- Existing BOM data can be migrated without losing referential integrity (IDs preserved).
</success_criteria>

<output>
After completion, create `.planning/phases/01-project-package-scoping-entry-ux/01-01-SUMMARY.md`
</output>
